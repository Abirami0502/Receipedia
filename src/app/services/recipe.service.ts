import { Injectable } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError, BehaviorSubject, of } from 'rxjs';
import { catchError, tap } from 'rxjs/operators';
import { Recipe } from '../models/recipe.model'; // Adjust path as needed

@Injectable({
  providedIn: 'root'
})
export class RecipeService {
  // API URL for backend operations
  private apiUrl = 'http://localhost:3000/api/recipes'; // Your actual backend API URL

  // --- BEGIN: Like/Favorite Functionality (Client-Side with LocalStorage) ---
  private likedRecipeIdsKey = 'likedRecipeIds_v1'; // Added a version to avoid conflicts with old keys
  private likedRecipeIdsSet: Set<string> = new Set<string>();
  // BehaviorSubject to notify subscribers (like a navbar count) about changes in liked recipes
  private likedRecipesCount = new BehaviorSubject<number>(0);
  public likedRecipesCount$ = this.likedRecipesCount.asObservable();
  // --- END: Like/Favorite Functionality ---

  constructor(private http: HttpClient) {
    // --- BEGIN: Load Likes on Initialization ---
    if (this.isLocalStorageAvailable()) {
      const storedLikes = localStorage.getItem(this.likedRecipeIdsKey);
      if (storedLikes) {
        try {
          const parsedLikes = JSON.parse(storedLikes);
          if (Array.isArray(parsedLikes)) {
            this.likedRecipeIdsSet = new Set(parsedLikes);
          } else {
            // Handle potential old format or corruption if necessary
            this.likedRecipeIdsSet = new Set();
            localStorage.removeItem(this.likedRecipeIdsKey); // Clear corrupted data
          }
        } catch (e) {
          console.error('Error parsing liked recipes from localStorage:', e);
          this.likedRecipeIdsSet = new Set(); // Reset on parsing error
          localStorage.removeItem(this.likedRecipeIdsKey); // Clear corrupted data
        }
        this.updateLikedRecipesCount();
      }
    } else {
        console.warn('LocalStorage is not available. Recipe favorites will not be persisted across sessions.');
    }
    // --- END: Load Likes on Initialization ---
  }

  private isLocalStorageAvailable(): boolean {
    try {
      const testKey = '__testLocalStorage__';
      localStorage.setItem(testKey, testKey);
      localStorage.removeItem(testKey);
      return true;
    } catch (e) {
      return false;
    }
  }

  // --- BEGIN: Like/Favorite Methods (Client-Side) ---
  private saveLikesToLocalStorage(): void {
    if (this.isLocalStorageAvailable()) {
      localStorage.setItem(this.likedRecipeIdsKey, JSON.stringify(Array.from(this.likedRecipeIdsSet)));
      this.updateLikedRecipesCount();
    }
  }

  private updateLikedRecipesCount(): void {
    this.likedRecipesCount.next(this.likedRecipeIdsSet.size);
  }

  /**
   * Checks if a recipe is marked as liked.
   * @param recipeId The ID of the recipe to check.
   * @returns True if the recipe is liked, false otherwise.
   */
  isLiked(recipeId: string | undefined): boolean {
    if (!recipeId) return false;
    return this.likedRecipeIdsSet.has(recipeId);
  }

  /**
   * Toggles the like status of a recipe.
   * Adds to favorites if not liked, removes if already liked.
   * @param recipeId The ID of the recipe to toggle.
   */
  toggleLike(recipeId: string | undefined): void {
    if (!recipeId) {
        console.warn('toggleLike called with undefined recipeId');
        return;
    }

    if (this.likedRecipeIdsSet.has(recipeId)) {
      this.likedRecipeIdsSet.delete(recipeId);
    } else {
      this.likedRecipeIdsSet.add(recipeId);
    }
    this.saveLikesToLocalStorage();
  }

  /**
   * Gets an array of all liked recipe IDs.
   * @returns An array of strings representing the IDs of liked recipes.
   */
  getLikedRecipeIds(): string[] {
    return Array.from(this.likedRecipeIdsSet);
  }
  // --- END: Like/Favorite Methods (Client-Side) ---

  // --- Backend HTTP Methods ---
  getRecipes(): Observable<Recipe[]> {
    return this.http.get<Recipe[]>(this.apiUrl).pipe(
      catchError(this.handleError)
    );
  }

  getRecipe(id: string): Observable<Recipe> {
    return this.http.get<Recipe>(`${this.apiUrl}/${id}`).pipe(
      catchError(this.handleError)
    );
  }

  createRecipe(recipe: Omit<Recipe, '_id'>): Observable<Recipe> { // Use Omit if _id is generated by backend
    return this.http.post<Recipe>(this.apiUrl, recipe).pipe(
      catchError(this.handleError)
    );
  }

  updateRecipe(recipe: Recipe): Observable<Recipe> {
    if (!recipe._id) {
      return throwError(() => new Error('Recipe ID is required for update.'));
    }
    return this.http.put<Recipe>(`${this.apiUrl}/${recipe._id}`, recipe).pipe(
      catchError(this.handleError)
    );
  }

  deleteRecipe(id: string): Observable<void> { // Typically, delete returns no content or a success message
    return this.http.delete<void>(`${this.apiUrl}/${id}`).pipe(
      tap(() => {
        // If a recipe is deleted from the backend, also remove it from client-side likes
        if (this.likedRecipeIdsSet.has(id)) {
          this.likedRecipeIdsSet.delete(id);
          this.saveLikesToLocalStorage();
        }
      }),
      catchError(this.handleError)
    );
  }

  private handleError(error: HttpErrorResponse) {
    let errorMessage = 'An unknown error occurred with the Recipe API!';
    if (error.error instanceof ErrorEvent) {
      // A client-side or network error occurred. Handle it accordingly.
      errorMessage = `Client-side error: ${error.error.message}`;
    } else {
      // The backend returned an unsuccessful response code.
      // The response body may contain clues as to what went wrong.
      errorMessage = `Server-side error (Code: ${error.status}): ${error.message}`;
      if (error.error && typeof error.error === 'string') {
        errorMessage += ` - ${error.error}`;
      } else if (error.error && error.error.message) {
        errorMessage += ` - ${error.error.message}`;
      }
    }
    console.error('RecipeService Error:', error); // Log the full error
    // It's good practice to also inform the user via NotificationService if appropriate,
    // but the service itself should just throw the error for the component to handle UI.
    return throwError(() => new Error(errorMessage));
  }
}
